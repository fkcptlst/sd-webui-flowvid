from itertools import product

import numpy as np
from torch.nn import functional as F
import torch
from torch import nn
from torch import Tensor
from torch.cuda.amp import autocast


def forward_warp(image_1: Tensor, flow: Tensor) -> Tensor:
    """Generate shifted coordinate grid based on input flow.

    Args:
        image_1 (Tensor): The first image.
        flow (Tensor): Estimated optical flow. (B, 2, H, W)

    Returns:
        Tensor: The warped image.
    """
    B, _, H, W = flow.shape

    xx = torch.arange(0, W, device=flow.device, requires_grad=False)
    yy = torch.arange(0, H, device=flow.device, requires_grad=False)

    # xx, yy = torch.meshgrid(yy, xx)
    xx = xx.repeat(H, 1)
    yy = yy.repeat(W, 1).t()

    new_x_coords = torch.round(xx + flow[:, 0, ...]).clamp(0, W - 1).int()  # (B, H, W)
    new_y_coords = torch.round(yy + flow[:, 1, ...]).clamp(0, H - 1).int()  # (B, H, W)

    I_1to2 = torch.zeros_like(image_1)

    for b, x, y in product(range(B), range(W), range(H)):  # TODO: vectorize
        I_1to2[b, :, new_y_coords[b, y, x], new_x_coords[b, y, x]] = image_1[b, :, y, x]

    return I_1to2


def coords_grid_back_warp(flow: Tensor) -> Tensor:
    """Generate shifted coordinate grid based on input flow.

    Args:
        flow (Tensor): Estimated optical flow. (B, 2, H, W)

    Returns:
        Tensor: The coordinate that shifted by input flow and scale in the
            range [-1, 1].
    """
    B, _, H, W = flow.shape
    xx = torch.arange(0, W, device=flow.device, requires_grad=False)
    yy = torch.arange(0, H, device=flow.device, requires_grad=False)
    coords = torch.meshgrid(yy, xx)
    coords = torch.stack(coords[::-1], dim=0).float()
    grid = coords[None].repeat(B, 1, 1, 1) + flow
    grid[:, 0, ...] = grid[:, 0, ...] * 2. / max(W - 1, 1) - 1.
    grid[:, 1, ...] = grid[:, 1, ...] * 2. / max(H - 1, 1) - 1.
    grid = grid.permute(0, 2, 3, 1)
    return grid


# Borrowed from mmflow
class Warp(nn.Module):
    """Warping layer to warp feature using optical flow.

    Args:
        mode (str): interpolation mode to calculate output values. Options are
            'bilinear' and 'nearest'. Defaults to 'bilinear'.
        padding_mode (str): padding mode for outside grid values. Options are
            'zero', 'border' and 'reflection'. Defaults to 'zeros'.
        align_corners (bool): If set to True, the extrema (-1 and 1) are
            considered as referring to the center points of the input’s corner
            pixels. If set to False, they are instead considered as referring
            to the corner points of the input’s corner pixels, making the
            sampling more resolution agnostic. Default to False.
    """

    def __init__(self,
                 mode: str = 'bilinear',
                 padding_mode: str = 'zeros',
                 align_corners: bool = False,
                 use_mask: bool = True) -> None:
        super().__init__()
        self.mode = mode
        self.padding_mode = padding_mode
        self.align_corners = align_corners
        self.use_mask = use_mask

    def forward(self, feat: Tensor, flow: Tensor) -> Tensor:
        """Forward function for warp.

        Args:
            feat (Tensor): Input feature, shape (B, C, H, W)
            flow (Tensor): Input optical flow. shape (B, 2, H, W)

        Returns:
            Tensor: The output feature that was generated by warping input
                feature based input flow.
        """
        grid = coords_grid_back_warp(flow)

        with autocast(enabled=False):
            out = F.grid_sample(
                feat.float(),
                grid,
                mode=self.mode,
                padding_mode=self.padding_mode,
                align_corners=self.align_corners)

        mask = torch.ones_like(feat, requires_grad=False)
        if self.use_mask:
            with autocast(enabled=False):
                mask = F.grid_sample(
                    mask.float(),
                    grid,
                    mode=self.mode,
                    padding_mode=self.padding_mode,
                    align_corners=self.align_corners)
                mask = (mask > 0.9999).float()
        return out * mask

    def __repr__(self):
        s = self.__class__.__name__
        s += f'(mode={self.mode}, '
        s += f'padding_mode={self.padding_mode}, '
        s += f'align_corners={self.align_corners},'
        s += f'use_mask={self.use_mask})'
        return s


def warp(image: np.ndarray, flow: np.ndarray, warp_mode='forward') -> np.ndarray:
    """
    Warp an image using optical flow
    :param image: image to warp, (h, w, c)
    :param flow: optical flow, (h, w, 2)
    :return: warped image in numpy array, (h, w, c)
    """
    image = image.astype(np.float32)
    flow = flow.astype(np.float32)
    flow = torch.from_numpy(flow).unsqueeze(0)  # (1, h, w, 2)
    flow = flow.permute(0, 3, 1, 2)  # (1, 2, h, w)
    image = torch.from_numpy(image).permute(2, 0, 1).unsqueeze(0)  # (1, c, h, w)

    if warp_mode == 'backward':
        warp_layer = Warp()
        warped_image = warp_layer(image, flow)  # (1, c, h, w)

    elif warp_mode == 'forward':
        warped_image = forward_warp(image, flow)  # (1, c, h, w)

    warped_image = warped_image.squeeze(0).permute(1, 2, 0).numpy()  # (h, w, c)
    warped_image = warped_image.astype(np.uint8)

    return warped_image
